#include "arduino.ceu"
#define FFR
#define TRIGGER_PIN_T  10
#define ECHO_PIN_T     11
#define TRIGGER_PIN_F  12
#define ECHO_PIN_F     13
#define TRIGGER_PIN_F2  0
#define ECHO_PIN_F2     1
#define MAX_DISTANCE 200
#define ENCODER_PIN_R 2
#define ENCODER_PIN_L 8
#define FLAME A0
#define BUZZER_PIN 3

native do
	##include <PID_v1.h>
	double setpointR, outputR, inputR;
	double setpointL, outputL, inputL;
	PID pidR(&inputR, &outputR, &setpointR, 2, 3, 0, DIRECT);
	PID pidL(&inputL, &outputL, &setpointL, 2, 3, 0, DIRECT);

	##include <NewPing.h>
		
	NewPing frontSonar(TRIGGER_PIN_F, ECHO_PIN_F, MAX_DISTANCE);
	NewPing frontSonar2(TRIGGER_PIN_F2, ECHO_PIN_F2, MAX_DISTANCE);
	NewPing turnSonar(TRIGGER_PIN_T, ECHO_PIN_T, MAX_DISTANCE);

	##include <Servo.h> 
	Servo myservo;

	typedef struct motor
	{
	  float vel;
	  int pinVel;
	  int pinWay;
	};
	typedef struct motor Motor;

	Motor rightM = {0, 5, 4};
	Motor leftM = {0, 6, 7};
end

input int ENCODER_R;
input int ENCODER_L;
_setpointR = 25;
_setpointL = _setpointR;
_pidR.SetMode(_AUTOMATIC);
_pidL.SetMode(_AUTOMATIC);
_myservo.attach(9);

_analogWrite(BUZZER_PIN, 100);
await 200ms;
_analogWrite(BUZZER_PIN, 0);

class Encoder with
	var int pin;
	var bool dir;
do
	event int encoder;
	par do 
		var int old = _LOW;
		loop do
			var int cur = _digitalRead( this.pin );
			
			if cur != old then
				old = cur;
				emit encoder => cur;
			end
			await 5ms; //debouncing
		end
	with
		loop do
			var int c = 0;
			watching 300ms do
				every encoder do
					c = c + 1;
				end
			end

			
			if this.dir then
				_inputR = c;
				_pidR.Compute();
				_rightM.vel = _outputR;
			else
				_inputL = c;
				_pidL.Compute();
				_leftM.vel = _outputL;
			end
		end
	end
end

class Buzzer with do
	finalize with
		_analogWrite( BUZZER_PIN, 0 );
	end
	_analogWrite( BUZZER_PIN, _rand() % 255 );
	await (100 + (_rand() % 50)) ms;
	_analogWrite( BUZZER_PIN, 0 );
	await (50 + (_rand() % 50)) ms;
	_analogWrite( BUZZER_PIN, _rand() % 255 );
	await (100 + (_rand() % 50)) ms;
	_analogWrite( BUZZER_PIN, 0 );
	await (50 + (_rand() % 50)) ms;
	if _rand() % 10 > 5 then
		_analogWrite( BUZZER_PIN, _rand() % 255 );
		await (100 + (_rand() % 50)) ms;
	end
	if _rand() % 10 > 5 then
		_analogWrite( BUZZER_PIN, 0 );
		await (50 + (_rand() % 50)) ms;
	end

	if _rand() % 10 > 2 then
		var int freq = _rand() % 255;
		var int dFreq = 0;
		loop do
			if freq < 0 then
				break;
			end
			_analogWrite( BUZZER_PIN, freq );
			await 30ms;

			freq = freq - dFreq;
			dFreq = dFreq + _rand() % 10 + 1;
			_analogWrite( BUZZER_PIN, 0 );
			await 10ms;
		end
	end
end

class VerifyDist with do
	var int minDist = 20;
	var int distFromFWall;
	var int testDistF = _frontSonar.ping()/_US_ROUNDTRIP_CM;
	var int testDistF2 = _frontSonar2.ping()/_US_ROUNDTRIP_CM;
	if testDistF > 0 and testDistF2 > 0 then
		if testDistF < testDistF2 then
			distFromFWall = testDistF;
		else
			distFromFWall = testDistF2;
		end
	  	// _Serial.print("Ping: ");
	  	// _Serial.print(distFromFWall);
	  	// _Serial.println("cm");
	  	if distFromFWall < minDist then
	  		escape 0;
		end
	end
	await 50ms;
end

class GoFoward with do
	finalize with
	    _digitalWrite( _rightM.pinWay, _HIGH );
	    _digitalWrite( _leftM.pinWay, _HIGH );
	    _analogWrite( _rightM.pinVel, 0 );
	    _analogWrite( _leftM.pinVel,  0 );
	end

	var Encoder _ with
		this.pin = ENCODER_PIN_R;
		this.dir = true;
	end;

	var Encoder _ with
		this.pin = ENCODER_PIN_L;
		this.dir = false;
	end;

	every 80ms do
		_digitalWrite( _rightM.pinWay, _HIGH );
	    _digitalWrite( _leftM.pinWay, _HIGH );
	    _analogWrite( _rightM.pinVel, _rightM.vel );
	    _analogWrite( _leftM.pinVel,  _leftM.vel );
    end	
end

class Turn with do
	finalize with
	    _digitalWrite( _rightM.pinWay, _HIGH );
	    _digitalWrite( _leftM.pinWay, _HIGH );
	    _analogWrite( _rightM.pinVel, 0 );
	    _analogWrite( _leftM.pinVel,  0 );
	end

	var int servoPos = 0;
	var int sideDistance;

	_analogWrite( _rightM.pinVel, 0 );
    _analogWrite( _leftM.pinVel,  0 );

    await 50ms;

	_digitalWrite( _rightM.pinWay, _LOW );
    _digitalWrite( _leftM.pinWay, _LOW );
    _analogWrite( _rightM.pinVel, 160 );
    _analogWrite( _leftM.pinVel,  160 );

    await 100ms;

    _analogWrite( _rightM.pinVel, 0 );
    _analogWrite( _leftM.pinVel,  0 );

    do Buzzer;

    _myservo.write(servoPos);
    await 200ms;
    sideDistance = _turnSonar.ping()/_US_ROUNDTRIP_CM;
    await 50ms;
    servoPos = 180;
    _myservo.write(servoPos);
    await 1s;
    _digitalWrite( _rightM.pinWay, _HIGH );
    _digitalWrite( _leftM.pinWay, _HIGH );
    if sideDistance > _turnSonar.ping()/_US_ROUNDTRIP_CM then
    	_digitalWrite( _rightM.pinWay, _HIGH );
    	_digitalWrite( _leftM.pinWay, _LOW );
    else
    	_digitalWrite( _rightM.pinWay, _LOW );
    	_digitalWrite( _leftM.pinWay, _HIGH );
    end

    _analogWrite( _rightM.pinVel, 200 );
    _analogWrite( _leftM.pinVel,  200 );

    await 200ms;

    _analogWrite( _rightM.pinVel, 0 );
    _analogWrite( _leftM.pinVel,  0 );

    servoPos = 0;
    _myservo.write(servoPos);
    await 500ms;
    _analogWrite( _rightM.pinVel, 0 );
    _analogWrite( _leftM.pinVel, 0 );
    /*_outputL = 0;
    _outputR = 0;*/
    await 1s;
end


class FireCheck with
do
	var int flameSensor = _analogRead(0);

	if flameSensor > 300 then
		escape 0;
	else
		await 300ms;
	end
end

class Apitar with
do
	loop do
		_analogWrite(BUZZER_PIN, 200);
		await 250ms;
		_analogWrite(BUZZER_PIN, 70);
		await 250ms;
	end
end

var FireCheck fogo;
watching fogo do
	loop do
		do
			var VerifyDist perto;
			watching perto do
				do GoFoward;
			end
		end
		do Turn;
	end
end
do Apitar;